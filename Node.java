package com.company;
import java.util.Scanner;

public class Node {
    private BD head = null;
    private static int count = 0;

    /**
     *
     * @return Получение количества элементов контейнера
     */
    public int getCount()
    {
        return count;
    }

    /**
     *
     * @return Проверка массива на наличие элементов
     */
    public boolean isEmpty() {
        return (head == null);
    }
    /**
     * @param num номер будущего элемента в контейнере
     * @return Возвращает ссылку на элемент, после которого будет добавлен данный элемент, определение элемента, после которого будет добавлен данный элемент, используется в методе AddElem()
     */
    public BD detthenumber(int num) {
        //System.out.println("Введите номер ячейки, в которой должен оказаться Ваш элемент: ");
        BD node = new BD();
        node = head;
        for (int i = 0; i < num - 2; i++) { // и
            node = node.getNext();
        }
        return node; // возвращает ссылку на узел, чтобы, используя ее, можно было легко соединить новый элемент с его будущими соседями
    }
    // приведу пример: если нам надо поставить элемент на третье место в массиве 1,2,3,4..., то мы должны дойти до 2 ячейки
    // и обозвать ее Нодом, тем самым совершив лишь один прыжок с 1 на 2. Таким образом, чтобы получить 1 нужно из тройки вычесть 2
    // где 3 - позиция, на которую надо поставить новый элемент, а 1 - количество прыжков
    // по такой схеме была выбрана та двойка в цикле Фор
    // это работает на любом участке массива кроме 1 и 2 значений. в этим случаях num будет либо нулем, либо отрицательным
    // для решения этого вопроса были созданы следующие функции: ЭдФерст и ЭдСеконд
    // в них описаны частные случаи, возникающие при добавлении элементов в массив (с удалением та же система)
    // они вызываются в функции ЭдЭлем

    /**
     * @param valuee значение элемента
     * Добавление значения в первую ячейку и увеличение значения переменной,
     *               отвечающей за кол-во эл-тов контейнера, на единицу, используется в методе AddElem()
     */
    public void addFirst(String valuee) {
        BD node = new BD();
        node.setValue(valuee);
        node.setNext(head);
        head = node;
        count++;
    }
    /**
     * @param valuee значение элемента
     * добавление значения во вторую ячейку и увеличение значения переменной,
     *               отвечающей за кол-во эл-тов контейнера, на единицу, используется в методе AddElem()
     */
    public void addSecond(String valuee) {
        BD node = new BD();
        node.setValue(valuee);
        node.setNext(head.getNext());
        head.setNext(node);
        count++;
    }
    /**
     * @param valuee значение элемента
     * @param num номер ячейки, в которой должен оказаться данный элемент
     * Добавление значения в конкретную ячейку(в ячейку num) и увеличение значения переменной,
     *               отвечающей за кол-во эл-тов контейнера, на единицу
     * В случае, если контейнер пустой, а пользователь хочется поставить элемент не на первое место,
     *            выводится сообщение о том, что так сделать не получится, и элемент займет первую ячейку.
     * Если не пустой и номер элемента не выходит за рамки массива + превышает двойку,
     *            то вставляем его на нужное место иначе пишем, что такого места нет.
     *            Если же необходимо вставить его на 1 или 2 места, попадаем в соответствующие функции.
     */
    public void addElem(String valuee, int num) {
        BD node = new BD();
        BD temp = new BD();
        node.setValue(valuee);
        if (isEmpty()) {
            head = node;
            head.setValue(node.getValue());
            System.out.println("Массив был пуст, Ваше значение записалось в первую и единственную ячейку");
            count++;
        } else {
            if (num == 1) {
                addFirst(valuee);
            } else if (num == 2) {
                addSecond(valuee);
            } else if (num > 2) {
                if(num <= count + 1)
                {
                    node = detthenumber(num);
                    node.setNext(temp);
                    temp.setNext(node.getNext());
                    temp.setValue(valuee);
                    count++;
                }
                else System.out.println("Нет такого места для элемента!");
            }
        }
    }

    /**
     * @param num номер нужного элемента
     * @return Значение искомого элемента или сообщение о выходе за границы контейнера, идем по контейнеру и, доходя до нужного элемента, выводим его значение
     * Проверяем не запрашиваем ли мы элемент, которого нет(то есть выход за границы контейнера), если это так, выводится сообщение об ошибке
     */
    public String getElem(int num)
    {
        BD node = new BD();
        node = head;
        if(num <= count)
        {
            for (int i = 0; i < num - 1; i++) {
                node = node.getNext();
            }
            return node.getValue();
        }
        else return "Такого элемента не существует!";
    }
    /**
     * удаление первого элемента контейнера с уменьшением каунта на единицу, проверка кол-ва эл-том массива. В случае, если ни одлного не осталось,
     *      у нас был массив из одного элемента, а значит нужно обьнулить голову списка,
     *      чтобы проходить корректно проверку на пустоту массива, иначе был удален первый элемент при том, что в массиве были и другие элементы, используется в методе delElem()
     */
    public void delFirst() {
        BD node = new BD();
        node = head;
        head = head.getNext();
        node = null;
        count--;
        if(count == 0)
        {
            head = null;
        }
    }
    /**
     * удаление второго элемента контейнера с уменьшением каунта на единицу, используется в методе делЭлем()
     */
    public void delSecond() {
        BD node = new BD();
        node = head.getNext();
        head.setNext(node.getNext());
        node = null;
        count--;
    }
    /**
     * @param num номер элемента, который надо удалить
     * Проверка массива на пустоту. Если это так, выводится сообщение о том, что он пуст, удалять нечего
     * Аналогично с методом добавления элементов проверяется выход за границы.
     *            Другими словами не получится удалить элемент, которого нет(при пяти эл-тах удалить 23ий).
     *            Если номер элемента 1 или 2 переходим в соответствующие методы - delFirst() и delSecond() соответственно
     * Дохождение до нужного элемента осуществляется посредством метода detThenumber()
     * каунт--
     */
    public void delElem(int num) {
        BD node = new BD();
        BD temp = new BD();
        if (isEmpty()) {
            head = node;
            System.out.println("Массив и так пустой");
        } else {
            if (num == 1) {
                delFirst();
            } else if (num == 2) {
                delSecond();
            } else if (num > 2) {
                if(num <= count)
                {
                    node = detthenumber(num);
                    temp = node.getNext();
                    node.setNext(temp.getNext());
                    temp = null;
                    node = null;
                    count--;
                }
                else System.out.println("Такого элемента не существует! ");
            }
        }
    }
    /**
     * Вывод массива.
     * Проверка на пустоту. Если это так, выводится сообщение об этом.
     */
    public void displayInfo()
    {
        BD node = new BD();
        node = head;
        if (isEmpty())
        {
            System.out.println("Массив пуст!");
        }
        else {
            for(int i = 0; i < count; i++)
            {
                System.out.println(node.getValue());
                node=node.getNext();
            }
        }
        node = null;
    }
}
